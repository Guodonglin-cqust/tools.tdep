#! /usr/bin/env python3.6

from argparse import ArgumentParser as argpars
import numpy as np
from parse_MD import parse_traj

parser = argpars(description='Read forces and positions from aims')
parser.add_argument('files', type=str, nargs='+', help='aims output files')
parser.add_argument('-n', type = int, default = 1, help='step count')
parser.add_argument('-d', type = int, default = 0, help='discard this many steps')
parser.add_argument('-nm', '--no_meta', action='store_true', help='dont store meta info')
parser.add_argument('--rearrange', type=str, default=None)
args = parser.parse_args()

lattice      = []
lattice_temp = []
positions    = []
forces       = []
symbols      = []

if args.rearrange:
    from pickletools import pread
    print(f'Rearrange forces and positions with the matching positions read from {args.rearrange}')
    match_list = pread(args.rearrange)
    #
    print(f'  {len(match_list)} matches found.')
    scell_args = [elem[1] for elem in match_list]
else:
    scell_args= range(n_atoms) #[l[1] for l in atom.match_list]

#
# Parse the trajectory
atom0, traj = parse_traj(args.files)

#
n_MD_full = len(traj) - 1

# Discard configurations that don't have a force calculator attached (e.g. start and end config of MD)
traj = [atom for atom in traj[1:] if atom.get_forces() is not None]

# Choose step width
traj = traj[args.d::args.n]

# Count
n_MD = len(traj)
n_atoms = len(atom0.get_chemical_symbols())

# Feedback
print(f'  MD step width selected:           {args.n}')
print(f'  Discard first n steps:            {args.n}')
print(f'  number of MD steps provided:      {n_MD_full}')
print(f'  number of MD steps parsed:        {n_MD}')
print(f'  number of atoms in supercell:     {n_atoms}')
print(f'  number of pos/forces extracted:   {n_atoms} * {n_MD} = {n_atoms*n_MD}')
if args.rearrange:
    print(f'  Forces and positions rearranged:   Yes')
else:
    print(f'  Forces and positions rearranged:   No')

# Write files
with open('infile.forces', 'w') as ff, open('infile.positions', 'w') as fp:
    for ii, atom in enumerate(traj):
        print(f'Write pos, force for atom {ii}')
        positions = atom.get_scaled_positions()[scell_args]
        forces    = atom.get_forces()[scell_args]
        for jj, (pos, force) in enumerate(zip(positions, forces)):
            (px, py, pz) = pos
            (fx, fy, fz) = force
            fp.write(f'{px:23.15} {py:23.15} {pz:23.15}\n')
            ff.write(f'{fx:23.15} {fy:23.15} {fz:23.15}\n')
#
print('\n  infile.forces written.')
print('  infile.positions written.\n')

# Store Meta info:
if not args.no_meta:
    with open('infile.meta', 'w') as f:
        f.write(f'{n_atoms}     # N atoms\n')
        f.write(f'{n_MD}        # N timesteps\n')
        f.write(f'{1.0}         # timestep in fs (currently not used norimplemented)\n')
        f.write(f'{30000}       # temperature in K (currently not used nor bimplemented)\n')
    #
    with open('infile.stat', 'w') as f:
        for ii in range(n_atoms * n_MD):
            f.write('0 0 0 0 0 0 0 0 0 0 0 0 0\n')
        #
    #
#
print('  (Mock) data written to infile.meta and infile.stat')
